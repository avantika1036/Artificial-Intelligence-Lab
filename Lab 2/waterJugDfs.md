# Water Jug Problem Solver (DFS Approach)

## Problem Statement
Given two jugs with known capacities and a target amount of water, determine whether it is possible to measure exactly the target amount using only the following operations:
- Fill a jug completely.
- Empty a jug.
- Pour water from one jug to the other until one is empty or the other is full.

---
## Approach
- Use **Depth-First Search (DFS)** to explore all possible states of the two jugs.
- Represent each state as a pair `(amountInJug1, amountInJug2)`.
- From each state, generate all possible next states by:
  1. Filling either jug.
  2. Emptying either jug.
  3. Pouring water from one jug to the other.
- Keep track of visited states to avoid infinite loops.
- Stop when the target is found in either jug or in the total of both.

---
## Implementation Details
- `waterJugDFS`: Core DFS logic using a stack for state exploration and a set to track visited states.
- `nextStates`: Generated by performing all possible valid operations from the current state.
- Main function takes user input for jug capacities and target amount, then runs DFS.

---
## Code (C++)

```cpp
#include <bits/stdc++.h>
using namespace std;

bool waterJugDFS(int jug1Cap, int jug2Cap, int target) 
{
    stack<pair<int, int>> st;  
    set<pair<int, int>> visited;

    st.push({0, 0}); 
    while (!st.empty()) {
        auto curr = st.top();
        st.pop();

        cout << "Current state: (" << curr.first << ", " << curr.second << ")\n";

        if (curr.first == target || curr.second == target || curr.first + curr.second == target) 
        {
            cout << "Reached target: (" << curr.first << ", " << curr.second << ")\n";
            return true;
        }

        if (visited.count({curr.first, curr.second})) continue;
        visited.insert({curr.first, curr.second});

        vector<pair<int, int>> nextStates;

        nextStates.push_back({jug1Cap, curr.second});

        nextStates.push_back({curr.first, jug2Cap});

        nextStates.push_back({0, curr.second});

        nextStates.push_back({curr.first, 0});

        {
            int pour = min(curr.first, jug2Cap - curr.second);
            nextStates.push_back({curr.first - pour, curr.second + pour});
        }

        {
            int pour = min(curr.second, jug1Cap - curr.first);
            nextStates.push_back({curr.first + pour, curr.second - pour});
        }

        for (auto &s : nextStates) 
        {
            if (!visited.count({s.first, s.second})) 
            {
                st.push(s);
            }
        }
    }

    return false;
}

int main() 
{
    int jug1Cap, jug2Cap, target;
    cout << "Enter capacity of Jug 1: ";
    cin >> jug1Cap;
    cout << "Enter capacity of Jug 2: ";
    cin >> jug2Cap;
    cout << "Enter target amount: ";
    cin >> target;

    if (waterJugDFS(jug1Cap, jug2Cap, target))
        cout << "Solution found!\n";
    else
        cout << "No solution possible!\n";

    return 0;
}

```
---

## Time Complexity
- Worst-case: **O(jug1Cap × jug2Cap)** (all possible states).
- DFS may explore deeply into one branch before backtracking.

## Space Complexity
- **O(jug1Cap × jug2Cap)** for storing visited states.

---
## Use Cases
- Classic AI search problem for understanding state-space exploration.
- Puzzle solving and algorithm learning.
- Foundation for more complex water distribution and resource allocation problems.

---
## Limitations
- DFS does not guarantee the shortest sequence of steps.
- Can explore unnecessary states before finding a solution.
- Limited to integer capacities and target amounts.
